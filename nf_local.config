report   { enabled = true; overwrite = true }
timeline { enabled = true; overwrite = true }
trace    { enabled = true }

// =====================================================
// TMP local (somente para processos Picard “sensíveis”)
// - Evita NFS flakey no SortingCollection.*.tmp
// - TMP fixo por processo (sem task.hash)
// =====================================================
def LOCAL_TMP_BASE = "/tmp/${System.getenv('USER') ?: 'user'}/isugif_tmp"

// -----------------------------------------------------
// Defaults (baixos) — o pipeline sobe nos processos pesados
// -----------------------------------------------------
process {
  cpus   = 2
  memory = 16.GB
  time   = '48h'

  // Ajuda a não entupir o storage com work dirs antigos
  scratch = false
}

// -----------------------------------------------------
// Java default conservador
// (os processos I/O-bound vão sobrescrever)
// -----------------------------------------------------
params {
  java_options = "-Xmx16g -XX:+UseParallelGC -Djava.io.tmpdir=${System.getenv('TMPDIR')}"
}

// ===============================
// I/O-bound (serializar mais)
// ===============================
//
// Aqui é onde seu erro acontece.
// Com muitos genomas, o gargalo é disco/temporários, não CPU/RAM.
//
process {

  // 1) PRINCIPAL CULPADO: FastqToSam
  withName: 'DNA_VARIANT_CALLING:FastqToSam' {
    cpus     = 2
    memory   = 48.GB
    time     = '48h'
    maxForks = 1

    // reduzir heap -> reduz spill / temp e volume de escrita
    ext.java_opts = "-Xmx16g -XX:+UseParallelGC -Djava.io.tmpdir=${System.getenv('TMPDIR')}"
  }

  // 2) MergeBamAlignment: usa SortingCollection -> precisa TMP local
  withName: 'DNA_VARIANT_CALLING:MergeBamAlignment_DNA' {
    cpus     = 3
    memory   = 64.GB
    time     = '72h'
    maxForks = 1

    // FORÇA TMP LOCAL (não-NFS) dentro do task
    beforeScript = """
      export TMPDIR="${LOCAL_TMP_BASE}/MergeBamAlignment_DNA"
      export SINGULARITY_TMPDIR="\$TMPDIR"
      export APPTAINER_TMPDIR="\$TMPDIR"
      mkdir -p "\$TMPDIR" && chmod 700 "\$TMPDIR"
    """

    // garante java.io.tmpdir = TMPDIR local
    ext.java_opts = '-Xmx24g -XX:+UseParallelGC -Djava.io.tmpdir=$TMPDIR'
  }

  // SortAndFixTags também pode usar temp pesado (Picard-ish)
  withName: 'DNA_VARIANT_CALLING:SortAndFixTags_DNA' {
    cpus     = 3
    memory   = 64.GB
    time     = '72h'
    maxForks = 1

    beforeScript = """
      export TMPDIR="${LOCAL_TMP_BASE}/SortAndFixTags_DNA"
      export SINGULARITY_TMPDIR="\$TMPDIR"
      export APPTAINER_TMPDIR="\$TMPDIR"
      mkdir -p "\$TMPDIR" && chmod 700 "\$TMPDIR"
    """

    ext.java_opts = '-Xmx24g -XX:+UseParallelGC -Djava.io.tmpdir=$TMPDIR'
  }

  // MarkDuplicates costuma gerar MUITO temp e I/O (SortingCollection)
  withName: 'DNA_VARIANT_CALLING:MarkDuplicates_DNA' {
    cpus     = 4
    memory   = 96.GB
    time     = '96h'
    maxForks = 1

    beforeScript = """
      export TMPDIR="${LOCAL_TMP_BASE}/MarkDuplicates_DNA"
      export SINGULARITY_TMPDIR="\$TMPDIR"
      export APPTAINER_TMPDIR="\$TMPDIR"
      mkdir -p "\$TMPDIR" && chmod 700 "\$TMPDIR"
    """

    ext.java_opts = '-Xmx32g -XX:+UseParallelGC -Djava.io.tmpdir=$TMPDIR'
  }

  // Se existir e for Java/GATK, também é I/O pesado
  withName: 'DNA_VARIANT_CALLING:SamToFastq_DNA' {
    cpus     = 2
    memory   = 32.GB
    time     = '48h'
    maxForks = 1
  }

  withName: 'DNA_VARIANT_CALLING:MarkIlluminaAdapters' {
    cpus     = 2
    memory   = 32.GB
    time     = '48h'
    maxForks = 1
  }
}

// ===============================
// CPU-bound (limitar para não “derreter” o disco)
// ===============================
process {

  withName: 'DNA_VARIANT_CALLING:bwamem2_mem' {
    cpus     = 16
    memory   = 96.GB
    time     = '72h'
    maxForks = 2
  }

  withName: 'DNA_VARIANT_CALLING:gatk_HaplotypeCaller_DNA' {
    cpus     = 12
    memory   = 96.GB
    time     = '96h'
    maxForks = 2
    ext.java_opts = "-Xmx48g -XX:+UseParallelGC -Djava.io.tmpdir=${System.getenv('TMPDIR')}"
  }
}

// ===============================
// Segurança extra: limite global de tasks concorrentes
// ===============================
executor {
  queueSize = 50
}
